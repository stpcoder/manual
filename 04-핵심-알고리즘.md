# 제4장 핵심 알고리즘

## 4.1 검출 파이프라인 개요

본 시스템의 손상 영역 검출 파이프라인은 Gaussian Mixture Model(GMM)과 Mahalanobis 거리를 결합한 픽셀 분류 방식을 사용합니다. 사용자가 배경(손상) 영역과 전경(원본 작품) 영역을 각각 하나 이상 지정하면, 각 영역으로부터 Gaussian 컴포넌트를 학습하고, 전체 이미지의 픽셀을 Mahalanobis 거리 기반으로 분류합니다. 이미 픽셀 단위의 정밀 분류가 이루어지므로 최소한의 후처리만 수행합니다.

### 4.1.1 전체 파이프라인 흐름

전체 파이프라인의 실행 순서는 다음과 같습니다.

```
이미지 로드
    |
    v
작품 경계 검출 (선택적, 4.6절 참조)
    |
    v
사용자 영역 선택
(배경/전경 영역 지정)
    |
    v
GMM 모델 학습
(각 영역별 Gaussian 컴포넌트 생성)
    |
    v
Mahalanobis 거리 기반 픽셀 분류
(LAB(L,a,b) + S 4차원 특성벡터)
    |
    v
후처리
(MORPH_CLOSE → GaussianBlur → 이진화)
    |
    v
형태학적 처리 (MORPH_OPEN)
    |
    v
윤곽선 추출
    |
    v
면적 필터 (min/max area)
    |
    v
공간 번호 부여 (grid 기반)
    |
    v
SVG 벡터 변환
```

---

## 4.2 GMM + Mahalanobis 거리 기반 분류

### 4.2.1 개요

본 절에서는 Gaussian Mixture Model(GMM)과 Mahalanobis 거리를 결합한 픽셀 분류 알고리즘을 기술합니다. 이 알고리즘은 사용자가 배경(손상) 영역과 전경(원본 작품) 영역을 각각 복수 개 지정하면 활성화됩니다.

### 4.2.2 단일 Gaussian과의 차이

단일 Gaussian 모델은 하나의 평균 벡터와 공분산 행렬로 정의되는 단일 타원형 결정 경계(decision boundary)만 형성합니다. 반면, GMM은 복수의 Gaussian 컴포넌트의 합집합으로 결정 영역을 구성하므로, 색이 서로 다른 복수의 손상 부위(예: 황변된 구멍과 백색 구멍이 혼재하는 경우)에 대해서도 효과적으로 대응할 수 있습니다.

### 4.2.3 특성벡터 공간

각 픽셀의 특성벡터(feature vector)는 4차원이며, 다음의 채널 값으로 구성됩니다.

```
f = (L, a, b, S)
```

여기서 L, a, b는 CIE LAB 색공간의 각 채널이고, S는 HSV 색공간의 채도 채널입니다. 4차원 특성벡터는 밝기, 색도, 채도 정보를 종합적으로 반영하여 손상 부위와 원본 작품 영역의 분류 정확도를 극대화합니다.

### 4.2.4 학습 단계

학습 단계는 `analyze_regions()` 메서드 호출 시 실행되며, 다음의 절차로 진행됩니다.

**Step 1: 컴포넌트 생성**

사용자가 선택한 각 영역(bounding box)에 대해, 해당 영역 내 모든 픽셀의 특성벡터를 추출하고, 이로부터 단일 Gaussian 컴포넌트를 생성합니다.

각 컴포넌트는 다음 3개의 매개변수로 정의됩니다.

```
component = { mean, cov_inv, weight }
```

여기서:

- **mean**: 특성벡터의 평균 (4차원 벡터)

  ```
  mu = (1/N) * sum(f_i),  i = 1, ..., N
  ```

- **cov_inv**: 공분산 행렬의 역행렬 (4x4 행렬)

  공분산 행렬은 다음과 같이 산출하며, 수치 안정성을 위해 정규화 항을 추가합니다.

  ```
  Sigma = cov(features) + 1e-4 * I
  cov_inv = Sigma^(-1)
  ```

  여기서 I는 4x4 단위 행렬입니다.

- **weight**: 해당 영역의 픽셀 수

**Step 2: 모델 구성**

배경(bg) 영역 N개와 전경(fg) 영역 M개로부터 각각 컴포넌트 리스트를 구성하여 GMM 모델을 저장합니다.

```
region_model = {
    type: 'gmm',
    bg_components: [comp_1, comp_2, ..., comp_N],
    fg_components: [comp_1, comp_2, ..., comp_M]
}
```

### 4.2.5 분류 단계

분류 단계는 `detect_with_filters()` 메서드 호출 시, 학습된 GMM 모델이 존재하는 경우에 자동으로 실행됩니다.

**청크 처리(Chunk Processing)**

초고해상도 이미지(예: 267MP 이상)에서의 메모리 효율을 보장하기 위해, 전체 픽셀을 고정 크기의 청크로 분할하여 순차 처리합니다.

```
CHUNK_SIZE = 2,000,000 픽셀 (약 64MB/청크)
n_chunks = ceil(total_pixels / CHUNK_SIZE)
```

**각 청크에 대한 처리**

1. 해당 청크 범위의 픽셀에 대해 4차원 특성벡터를 float64 타입으로 구성합니다.

   ```
   chunk_features = column_stack([L_flat[start:end], a_flat[start:end],
                                   b_flat[start:end], S_flat[start:end]])
   ```

2. 각 픽셀에서 배경 컴포넌트 집합까지의 최소 Mahalanobis 거리 제곱을 산출합니다.

   ```
   dist_bg = min( d(pixel, comp) )  for comp in bg_components
   ```

   여기서 Mahalanobis 거리 제곱은 다음과 같이 정의됩니다.

   ```
   d(x, comp) = (x - mu)^T * Sigma^(-1) * (x - mu)
   ```

3. 동일하게 전경 컴포넌트 집합까지의 최소 Mahalanobis 거리 제곱을 산출합니다.

   ```
   dist_fg = min( d(pixel, comp) )  for comp in fg_components
   ```

4. 배경(손상) 컴포넌트에 더 가까운 픽셀을 손상 부위로 분류합니다.

   ```
   mask = (dist_fg > dist_bg) * 255
   ```

**후처리**

청크 처리 완료 후, 전체 마스크에 대해 다음의 후처리를 순차 적용합니다.

1. **MORPH_CLOSE(3x3)**: 1-2 픽셀 수준의 경계 틈을 메웁니다.

   ```
   close_kernel = Ellipse(3, 3)
   mask = morphologyEx(mask, MORPH_CLOSE, close_kernel)
   ```

2. **GaussianBlur(7x7)**: 픽셀 수준의 계단 현상(jagged edge)을 완화합니다.

   ```
   mask = GaussianBlur(mask, (7, 7), 0)
   ```

3. **이진화 복원**: 블러링에 의해 중간값이 된 픽셀을 127을 기준으로 이진화합니다.

   ```
   mask = (mask > 127) * 255
   ```

### 4.2.6 알고리즘 특성

1. **하위 호환성**: 단일 영역 선택(배경 1개, 전경 1개)의 경우 컴포넌트가 각 1개이므로 기존의 단일 Gaussian Mahalanobis 분류와 동일한 결과를 산출합니다.
2. **메모리 효율**: 청크 처리에 의해 초고해상도 이미지에서도 피크 메모리 사용량을 약 200MB로 제한합니다.

---

## 4.3 형태학적 처리

이진 마스크에서 개별 손상 부위를 추출하기에 앞서, 노이즈를 제거하는 형태학적(morphological) 처리를 수행합니다. GMM 분류에서는 이미 픽셀 단위의 정밀 분류가 완료되어 있으므로, MORPH_OPEN만 적용합니다.

```
open_kernel = Ellipse(kernel_size, kernel_size)
mask_clean = morphologyEx(mask, MORPH_OPEN, open_kernel)
```

kernel_size는 해상도 스케일링에 의해 결정되며, 최소 3px입니다.

---

## 4.4 해상도 인식 파라미터 스케일링

### 4.4.1 필요성

본 시스템은 다양한 해상도의 스캔 이미지를 처리해야 합니다. 동일한 물리적 크기의 손상 부위라도 스캔 해상도에 따라 픽셀 면적이 비례적으로 변화하므로, 모든 파라미터를 해상도에 연동하여 자동 조정할 필요가 있습니다.

### 4.4.2 기준 해상도

본 시스템의 기준 해상도는 고해상도 TIFF 스캔의 대표적 크기인 7216 x 5412 픽셀입니다.

```
REFERENCE_PIXELS = 7216 * 5412 = 39,061,392 px
```

### 4.4.3 스케일 팩터 산출

현재 처리 중인 이미지의 너비 W와 높이 H로부터 두 종류의 스케일 팩터를 산출합니다.

**면적 스케일 팩터(area scale factor)**:

```
scale_factor = (W * H) / 39,061,392
```

이 값은 면적에 비례하는 파라미터(min_area, max_area 등)의 스케일링에 사용됩니다.

**선형 스케일 팩터(linear scale factor)**:

```
linear_scale = sqrt(scale_factor)
```

이 값은 길이에 비례하는 파라미터(커널 크기, 격자 크기 등)의 스케일링에 사용됩니다.

### 4.4.4 적용 대상

| 파라미터 유형 | 스케일링 방식 | 산출식 예시 |
|---------------|---------------|-------------|
| 면적 임계값 (min_area, max_area) | 면적 비례 | min_area_scaled = int(min_area * scale_factor) |
| 형태학적 커널 크기 | 선형 비례, 최소 3px | kernel_size = max(3, int(3 * linear_scale)) |
| morph_size | 선형 비례, 최소 5px | morph_size = max(5, int(9 * linear_scale)) |
| 격자 크기 (번호 부여) | 선형 비례 | grid_size_scaled = int(grid_size * linear_scale) |
| 가장자리 마진 | 선형 비례 | border_margin_scaled = int(margin * linear_scale) |

### 4.4.5 커널 크기 홀수 보정

OpenCV의 형태학적 연산에서 커널 크기는 홀수여야 합니다. 스케일링에 의해 짝수가 산출된 경우 1을 가산하여 홀수로 보정합니다.

```
if kernel_size % 2 == 0:
    kernel_size += 1
```

---

## 4.5 공간 번호 부여 알고리즘

### 4.5.1 목적

검출된 손상 부위에 물리적 위치에 기반한 일관된 번호를 부여하여, 커팅 레이아웃의 조각 번호와 원본 작품의 위치를 직관적으로 대응시키는 것을 목적으로 합니다.

### 4.5.2 Grid 방식 (기본)

Grid 방식은 이미지를 균일한 격자로 분할하고, 격자 단위로 그룹핑한 후 정렬하여 번호를 부여하는 방식입니다.

**Step 1: 격자 좌표 산출**

각 손상 부위의 중심점 (cx, cy)로부터 격자 좌표를 산출합니다. 기본 격자 크기(grid_size)는 500px입니다.

```
gx = cx // grid_size
gy = cy // grid_size
```

**Step 2: 격자 단위 그룹핑**

동일 격자 좌표 (gx, gy)를 가지는 손상 부위를 하나의 그룹으로 묶습니다.

**Step 3: 그룹 간 정렬**

그룹을 (gy, gx) 순서, 즉 상단에서 하단으로, 좌측에서 우측으로 정렬합니다.

```
sorted_keys = sorted(grid_assignments.keys(), key=lambda k: (k[1], k[0]))
```

**Step 4: 그룹 내 정렬**

각 그룹 내에서 손상 부위를 (y // 50, x) 순서로 세부 정렬합니다. 여기서 y // 50은 50px 간격의 행 단위 양자화로, 유사한 높이의 손상 부위를 동일 행으로 취급합니다.

```
sorted_group = sorted(group, key=lambda h: (center_y // 50, center_x))
```

**Step 5: 번호 부여**

정렬된 순서에 따라 1부터 시작하는 연속 번호를 부여합니다.

### 4.5.3 기타 번호 부여 방식

| 방식 | 그룹핑 기준 | 정렬 순서 |
|------|-------------|-----------|
| row | Y 좌표 기반 행 (row_height px 간격) | 행 순서(상->하), 행 내 좌->우 |
| column | X 좌표 기반 열 (col_width px 간격) | 열 순서(좌->우), 열 내 상->하 |
| simple | 단일 그룹 (그룹핑 없음) | Y 좌표 우선, X 좌표 보조 |

---

## 4.6 작품 경계 검출

### 4.6.1 목적

스캔 이미지에서 실제 작품 영역을 자동으로 식별하여, 스캐너 배경이 손상 부위로 오검출되는 것을 방지하는 것이 목적입니다. 작품 경계 외부의 영역은 마스크에서 제거됩니다.

### 4.6.2 방법 1: 밝기 기반 (brightness)

본 방법은 CIE LAB 색공간의 b 채널(청색-황색 축)을 이용합니다. 한국화 한지는 황변에 의해 b 값이 높고, 스캐너 배경은 흰색으로 b 값이 낮으므로 이 차이를 이용합니다.

**Step 1: b 채널 추출 및 Otsu 이진화**

```
lab = cvtColor(image, BGR2LAB)
L, a, b_channel = split(lab)
b_thresh, doc_mask = threshold(b_channel, 0, 255, BINARY + OTSU)
```

Otsu 알고리즘에 의해 최적 이진화 임계값이 자동 결정됩니다.

**Step 2: 형태학적 정리**

작품 내부의 구멍(작은 흰색 영역)을 메우기 위한 MORPH_CLOSE와, 외부 노이즈를 제거하기 위한 MORPH_OPEN을 순차 적용합니다. 커널 크기는 이미지 크기에 비례합니다.

```
kernel_close = max(20, int(min(W, H) * 0.005))
kernel_open  = max(5,  int(min(W, H) * 0.001))
doc_mask = morphologyEx(doc_mask, MORPH_CLOSE, Rect(kernel_close, kernel_close))
doc_mask = morphologyEx(doc_mask, MORPH_OPEN,  Rect(kernel_open,  kernel_open))
```

**Step 3: 최대 윤곽선 추출**

윤곽선을 검출하여 면적이 가장 큰 윤곽선을 작품 경계로 판정합니다. 최대 윤곽선의 면적이 이미지 전체의 30% 미만인 경우 경계 검출 실패로 처리합니다.

```
contours = findContours(doc_mask, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE)
largest_contour = max(contours, key=contourArea)
if contourArea(largest_contour) < W * H * 0.3:
    return None  (검출 실패)
```

**Step 4: 바운딩 사각형 산출**

최대 윤곽선으로부터 작품 영역의 바운딩 사각형 (x, y, w, h)을 산출합니다.

### 4.6.3 방법 2: 엣지 기반 (edges)

본 방법은 Canny 엣지 검출과 Hough 직선 검출을 결합하여 작품의 직선적 경계를 검출합니다.

**Step 1: Canny 엣지 검출**

```
gray = cvtColor(image, BGR2GRAY)
edges = Canny(gray, 50, 150)
```

**Step 2: Hough 직선 검출**

```
lines = HoughLinesP(edges, 1, pi/180,
                    threshold=100,
                    minLineLength=min(W, H) * 0.3,
                    maxLineGap=50)
```

**Step 3: 직선 분류**

검출된 직선을 각도에 따라 수평선(angle < 10 또는 angle > 170도)과 수직선(80 < angle < 100도)으로 분류합니다.

**Step 4: 경계 결정**

수평선의 최소 Y와 최대 Y, 수직선의 최소 X와 최대 X로부터 작품 경계 사각형을 결정합니다.

```
top    = min(horizontal_y_values)
bottom = max(horizontal_y_values)
left   = min(vertical_x_values)
right  = max(vertical_x_values)
boundary = (left, top, right - left, bottom - top)
```

수평선 또는 수직선이 2개 미만인 경우 경계 검출 실패로 처리합니다.

### 4.6.4 경계 적용

검출된 경계를 마스크에 적용하면, 경계 외부의 모든 픽셀이 0(비검출)으로 설정됩니다.

```
bounded_mask = zeros_like(mask)
bounded_mask[y_start:y_end, x_start:x_end] = mask[y_start:y_end, x_start:x_end]
```

---

## 4.7 윤곽선-SVG 벡터 변환

### 4.7.1 목적

검출된 각 손상 부위의 윤곽선을 SVG(Scalable Vector Graphics) path 형식으로 변환하여, 레이저 커터 호환 벡터 파일을 생성하는 것이 목적입니다.

### 4.7.2 Ramer-Douglas-Peucker 단순화

OpenCV의 `findContours`에 의해 추출된 윤곽선은 픽셀 단위의 다수의 꼭짓점을 포함하므로, Ramer-Douglas-Peucker 알고리즘을 적용하여 윤곽선의 형상을 보존하면서 꼭짓점 수를 감소시킵니다.

```
epsilon = 0.9
approx = approxPolyDP(contour, epsilon, closed=True)
```

여기서 epsilon은 원래 윤곽선으로부터의 최대 허용 편차(픽셀 단위)이며, 0.9 픽셀로 설정되어 있습니다. 이 값이 클수록 단순화 정도가 높아지고, 작을수록 원래 형상에 더 충실한 결과가 산출됩니다.

단순화 후 꼭짓점이 3개 미만인 경우 유효한 폐합 형상을 구성할 수 없으므로 빈 문자열을 반환합니다.

### 4.7.3 SVG Path 명령어

단순화된 윤곽선의 각 꼭짓점을 SVG path의 표준 명령어로 변환합니다.

| 명령어 | 의미 | 용례 |
|--------|------|------|
| M x,y | MoveTo -- 시작점으로 이동 | 경로의 첫 꼭짓점 |
| L x,y | LineTo -- 직선 그리기 | 두 번째 이후의 각 꼭짓점 |
| Z | ClosePath -- 시작점으로 경로 닫기 | 경로의 마지막 |

### 4.7.4 변환 절차

꼭짓점 배열 points = [(x_0, y_0), (x_1, y_1), ..., (x_n, y_n)]에 대해 다음의 SVG path 문자열을 생성합니다.

```
d = "M x_0,y_0 L x_1,y_1 L x_2,y_2 ... L x_n,y_n Z"
```

좌표값은 소수점 이하 4자리까지 기록하여 서브픽셀 정밀도를 유지합니다.

```
path_data = f"M {points[0][0]:.4f},{points[0][1]:.4f}"
for point in points[1:]:
    path_data += f" L {point[0]:.4f},{point[1]:.4f}"
path_data += " Z"
```

### 4.7.5 SVG 파일 출력

각 손상 부위에 대해 개별 SVG 파일을 생성합니다. 스케일 팩터(scale_factors)가 제공되는 경우, 픽셀 좌표를 실제 치수(mm)로 변환하여 SVG의 width/height 속성에 mm 단위를 적용합니다. 스케일 팩터가 미제공인 경우, 픽셀 단위의 SVG를 생성합니다.

```
실측 SVG의 경우:
  width  = (x_max - x_min) * scale_x  [mm]
  height = (y_max - y_min) * scale_y  [mm]
  transform = translate(-x_min * scale_x, -y_min * scale_y)
              scale(scale_x, scale_y)
```

---

## 4.8 가장자리 연결 영역 제거

### 4.8.1 적용 조건

작품 경계 검출(boundary detection) 기능이 비활성화(OFF)된 경우에 적용됩니다.

### 4.8.2 알고리즘

이미지의 4변(상, 하, 좌, 우) 가장자리에 위치한 흰색 픽셀(값 255)로부터 Flood Fill을 실행하여, 가장자리에서 연결된 모든 흰색 영역을 제거합니다.

```
for 상단 가장자리의 각 x:
    if mask[0, x] == 255:
        floodFill(mask, (x, 0), 0)

for 하단 가장자리의 각 x:
    if mask[H-1, x] == 255:
        floodFill(mask, (x, H-1), 0)

for 좌측 가장자리의 각 y:
    if mask[y, 0] == 255:
        floodFill(mask, (0, y), 0)

for 우측 가장자리의 각 y:
    if mask[y, W-1] == 255:
        floodFill(mask, (W-1, y), 0)
```

이를 통해 작품 경계 검출 없이도 스캐너 배경이 손상 부위로 오검출되는 현상을 억제합니다.
