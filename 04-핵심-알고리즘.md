# 제4장 핵심 알고리즘

## 4.1 검출 파이프라인 개요

본 시스템의 손상 영역 검출 파이프라인은 입력 이미지에 대해 두 가지 상호 배타적인 경로 중 하나를 선택하여 실행된다. 두 경로는 최종적으로 동일한 윤곽선 추출 및 벡터 변환 단계에 합류한다.

### 4.1.1 경로 A: 채널별 임계값 필터 경로

경로 A는 HSV 및 LAB 색공간의 개별 채널에 대해 사용자 정의 임계값을 적용하고, 그 결과를 논리 연산(AND 또는 OR)으로 결합하여 이진 마스크를 생성하는 방식이다. 해당 마스크에 대해 Canny 엣지 보정 및 공격적 형태학적 처리(dilate-erode bridging)를 순차 적용한다.

### 4.1.2 경로 B: GMM + Mahalanobis 거리 분류 경로

경로 B는 사용자가 배경(손상) 영역과 전경(원본 문서) 영역을 각각 하나 이상 지정하면, 각 영역으로부터 Gaussian 컴포넌트를 학습하고, 전체 이미지의 픽셀을 Mahalanobis 거리 기반으로 분류하는 방식이다. 해당 경로에서는 이미 픽셀 단위의 정밀 분류가 이루어지므로 Canny 엣지 보정 및 공격적 형태학적 bridging을 생략하고, 최소한의 후처리만 수행한다.

### 4.1.3 전체 파이프라인 흐름

전체 파이프라인의 실행 순서는 다음과 같다.

```
이미지 로드
    |
    v
문서 경계 검출 (선택적, 4.11절 참조)
    |
    v
+---------------------------+-------------------------------+
|  경로 A: 채널별 임계값     |  경로 B: Mahalanobis 분류     |
|  필터 적용                 |  (영역 분석 후 GMM 모델       |
|                            |   학습이 완료된 경우 자동     |
|  S, L, b, Tex, W          |   적용)                       |
|  채널 마스크 생성           |                               |
|  AND/OR 논리 결합          |  LAB(L,a,b) + S 4차원         |
|         |                  |  특성벡터 -> 거리 기반 분류    |
|         v                  |           |                   |
|  형태학적 처리             |           v                   |
|  + Canny 엣지 보정        |  MORPH_CLOSE(3x3)             |
|                            |  GaussianBlur(7x7)            |
|                            |  threshold(127) 이진화        |
+------------+---------------+--------------+----------------+
             |                              |
             v                              v
  윤곽선 추출                     윤곽선 추출
  (dilate -> erode -> OR          (MORPH_OPEN만 적용,
   -> MORPH_OPEN)                  bridging 생략)
             |                              |
             +---------------+--------------+
                             |
                             v
                    면적 필터 (min/max area)
                             |
                             v
                    공간 번호 부여 (grid 기반)
                             |
                             v
                    SVG 벡터 변환
```

상기 흐름에서, 경로 B가 활성화되면 경로 A의 채널별 임계값 필터는 무시되며, GMM 분류 결과만 사용된다.

---

## 4.2 HSV 색공간 기반 검출

### 4.2.1 검출 원리

HSV(Hue, Saturation, Value) 색공간에서 손상 부위(구멍)는 배경 종이가 노출되어 있으므로 다음의 특성을 보인다.

- **채도(S, Saturation)가 낮다**: 구멍을 통해 보이는 하층 배경은 무채색에 가까운 흰색이다.
- **명도(V, Value)가 높다**: 배경지 또는 스캐너 배경이 밝다.

따라서 채도가 소정의 임계값 미만이고, 동시에 명도가 소정의 임계값을 초과하는 픽셀을 손상 부위 후보로 판별한다.

### 4.2.2 기본 임계값

본 시스템에서 사용하는 HSV 채널의 기본 임계값은 다음과 같다.

| 채널 | 조건 | 기본값 | 의미 |
|------|------|--------|------|
| S (Saturation) | S < threshold | 30 | 채도 30 미만인 픽셀 |
| V (Value) | V > threshold | 200 | 명도 200 초과인 픽셀 |

### 4.2.3 Gap-Filling 메커니즘

단일 임계값만 적용하면 손상 부위 내부에 미세한 미검출 영역(gap)이 발생할 수 있다. 이를 해결하기 위해 본 시스템은 엄격(strict) 마스크와 완화(loose) 마스크의 2단계 접근법을 채택한다.

**1단계: Strict 마스크 생성**

엄격한 임계값을 적용하여 확실한 손상 부위만 추출한다.

```
mask_strict = (S < 30) AND (V > 200)
```

**2단계: Loose 마스크 생성**

완화된 임계값을 적용하여 경계 영역까지 포함하는 마스크를 생성한다.

```
mask_loose = (S < 40) AND (V > 190)
```

여기서 완화 임계값은 채도에 +10, 명도에 -10을 적용한 값이다.

**3단계: Gap Filling**

Strict 마스크를 7x7 타원형(Ellipse) 커널로 팽창(dilate)하여 주변 영역(neighborhood)을 생성하고, 해당 영역 내에서만 Loose 마스크를 활성화한다.

```
neighbor_kernel = Ellipse(7, 7)
mask_neighborhood = dilate(mask_strict, neighbor_kernel)
mask_gaps = mask_loose AND mask_neighborhood
```

**4단계: 최종 결합**

Strict 마스크와 Gap 마스크를 OR 연산으로 결합한다.

```
white_mask = mask_strict OR mask_gaps
```

**5단계: 이미지 가장자리 제거**

이미지 전체 크기의 5% 마진에 해당하는 가장자리 영역을 마스크에서 제거한다. 이는 스캔 과정에서 발생하는 문서 가장자리의 해짐이나 찢어짐이 손상 부위로 오검출되는 것을 방지하기 위함이다.

```
edge_margin = int(min(H, W) * 0.05)
white_mask[가장자리 영역] = 0
```

### 4.2.4 Gap-Filling의 핵심 원리

상기 Gap-Filling 메커니즘의 핵심은, Strict 마스크로 확정된 손상 부위의 인접 영역에서만 완화된 조건을 적용함으로써, 손상 부위 내부의 미검출 틈새를 보충하되 무관한 영역에서의 위양성(false positive)을 억제하는 데 있다. 이는 구멍 경계의 정밀한 추적과 오검출 억제를 동시에 달성한다.

---

## 4.3 LAB 색공간 기반 검출

### 4.3.1 검출 원리

CIE LAB 색공간의 b 채널은 청색-황색 축(blue-yellow axis)을 나타낸다. 고문서의 원본 종이는 경년 변화에 의해 황변(yellowing)이 진행되어 b 값이 높은 반면, 손상 부위로 노출된 하층 종이나 배경은 상대적으로 b 값이 낮다. 본 시스템은 이 차이를 이용하여 손상 부위를 검출한다.

### 4.3.2 기본 임계값

| 채널 | 조건 | 기본값 | 의미 |
|------|------|--------|------|
| b (LAB b 채널) | b < threshold | 138 | b 채널 값 138 미만인 픽셀 |

### 4.3.3 Gap-Filling 메커니즘

LAB b 채널 검출에서도 HSV와 동일한 구조의 Gap-Filling 메커니즘을 적용한다.

**1단계: Strict 마스크**

```
mask_strict = (b < 138)
```

**2단계: Loose 마스크**

기본 임계값에 6을 가산한 완화 임계값을 적용한다.

```
b_thresh_loose = 138 + 6 = 144
mask_loose = (b < 144)
```

**3단계: Gap Filling**

HSV 검출과 동일하게 7x7 타원형 커널을 사용한 주변 영역 기반 Gap Filling을 수행한다.

```
neighbor_kernel = Ellipse(7, 7)
mask_neighborhood = dilate(mask_strict, neighbor_kernel)
mask_gaps = mask_loose AND mask_neighborhood
```

**4단계: 최종 결합**

```
white_mask = mask_strict OR mask_gaps
```

### 4.3.4 파라미터 요약

| 파라미터 | 기본값 | 설명 |
|----------|--------|------|
| b_threshold | 138 | LAB b 채널 엄격 임계값 |
| b_threshold_loose | 144 (b_threshold + 6) | Gap Filling용 완화 임계값 |
| neighbor_kernel | 7x7 Ellipse | Strict 마스크 팽창 범위 |

---

## 4.4 Whiteness Score 기반 검출

### 4.4.1 검출 원리

Whiteness Score는 종이 색상에 독립적으로 작동하는 복합 지표로, 밝기와 채도를 동시에 고려하여 "흰색도"를 정량화한다. 이는 종이 색상이 다양한 고문서에 대해 범용적으로 적용 가능한 장점이 있다.

### 4.4.2 수학적 정의

CIE LAB 색공간의 L, a, b 값으로부터 Whiteness Score를 다음과 같이 산출한다.

**밝기 점수(brightness score)**:

```
brightness = L / 255
```

여기서 L은 CIE LAB의 명도(Lightness) 채널이며, OpenCV 구현에서 0-255 범위를 가진다. 산출값의 범위는 [0, 1]이다.

**채도(chroma)**:

```
saturation = sqrt((a - 128)^2 + (b - 128)^2)
```

여기서 a, b는 CIE LAB의 색도 채널이며, OpenCV 구현에서 128이 중립점이다. 중립점으로부터의 유클리드 거리가 채도를 나타내며, 이론적 최댓값은 다음과 같다.

```
max_saturation = 128 * sqrt(2) = 181.02
```

**Whiteness Score**:

```
W = (L / 255) * (1 - saturation / max_saturation)
```

산출값의 범위는 [0, 1]이며, W 값이 1에 가까울수록 해당 픽셀이 밝고 무채색인 순수한 흰색임을 나타낸다.

### 4.4.3 판정 기준

Whiteness Score가 소정의 임계값을 초과하는 픽셀을 손상 부위 후보로 판별한다. 임계값은 자동 분석 또는 수동 지정이 가능하며, 자동 분석 시에는 이미지 내 상위 5% 밝기 영역(구멍 후보)과 종이 영역의 Whiteness 분포를 비교하여 최적 임계값을 결정한다. 자동 분석에서 산출되는 임계값은 [0.82, 0.92] 범위로 제한된다.

---

## 4.5 GMM + Mahalanobis 거리 기반 분류

### 4.5.1 개요

본 절에서는 Gaussian Mixture Model(GMM)과 Mahalanobis 거리를 결합한 픽셀 분류 알고리즘을 기술한다. 이 알고리즘은 사용자가 배경(손상) 영역과 전경(원본 문서) 영역을 각각 복수 개 지정한 경우에 활성화되며, 채널별 임계값 필터 경로를 대체한다.

### 4.5.2 단일 Gaussian과의 차이

단일 Gaussian 모델은 하나의 평균 벡터와 공분산 행렬로 정의되는 단일 타원형 결정 경계(decision boundary)만 형성한다. 반면, GMM은 복수의 Gaussian 컴포넌트의 합집합으로 결정 영역을 구성하므로, 색이 서로 다른 복수의 손상 부위(예: 황변된 구멍과 백색 구멍이 혼재하는 경우)에 대해서도 효과적으로 대응할 수 있다.

### 4.5.3 특성벡터 공간

각 픽셀의 특성벡터(feature vector)는 4차원이며, 다음의 채널 값으로 구성된다.

```
f = (L, a, b, S)
```

여기서 L, a, b는 CIE LAB 색공간의 각 채널이고, S는 HSV 색공간의 채도 채널이다. 4차원 특성벡터는 밝기, 색도, 채도 정보를 종합적으로 반영하여 손상 부위와 원본 문서 영역의 분류 정확도를 극대화한다.

### 4.5.4 학습 단계

학습 단계는 `analyze_regions()` 메서드 호출 시 실행되며, 다음의 절차로 진행된다.

**Step 1: 컴포넌트 생성**

사용자가 선택한 각 영역(bounding box)에 대해, 해당 영역 내 모든 픽셀의 특성벡터를 추출하고, 이로부터 단일 Gaussian 컴포넌트를 생성한다.

각 컴포넌트는 다음 3개의 매개변수로 정의된다.

```
component = { mean, cov_inv, weight }
```

여기서:

- **mean**: 특성벡터의 평균 (4차원 벡터)

  ```
  mu = (1/N) * sum(f_i),  i = 1, ..., N
  ```

- **cov_inv**: 공분산 행렬의 역행렬 (4x4 행렬)

  공분산 행렬은 다음과 같이 산출하며, 수치 안정성을 위해 정규화 항을 추가한다.

  ```
  Sigma = cov(features) + 1e-4 * I
  cov_inv = Sigma^(-1)
  ```

  여기서 I는 4x4 단위 행렬이다.

- **weight**: 해당 영역의 픽셀 수

**Step 2: 모델 구성**

배경(bg) 영역 N개와 전경(fg) 영역 M개로부터 각각 컴포넌트 리스트를 구성하여 GMM 모델을 저장한다.

```
region_model = {
    type: 'gmm',
    bg_components: [comp_1, comp_2, ..., comp_N],
    fg_components: [comp_1, comp_2, ..., comp_M]
}
```

### 4.5.5 분류 단계

분류 단계는 `detect_with_filters()` 메서드 호출 시, 학습된 GMM 모델이 존재하는 경우에 자동으로 실행된다.

**청크 처리(Chunk Processing)**

초고해상도 이미지(예: 267MP 이상)에서의 메모리 효율을 보장하기 위해, 전체 픽셀을 고정 크기의 청크로 분할하여 순차 처리한다.

```
CHUNK_SIZE = 2,000,000 픽셀 (약 64MB/청크)
n_chunks = ceil(total_pixels / CHUNK_SIZE)
```

**각 청크에 대한 처리**

1. 해당 청크 범위의 픽셀에 대해 4차원 특성벡터를 float64 타입으로 구성한다.

   ```
   chunk_features = column_stack([L_flat[start:end], a_flat[start:end],
                                   b_flat[start:end], S_flat[start:end]])
   ```

2. 각 픽셀에서 배경 컴포넌트 집합까지의 최소 Mahalanobis 거리 제곱을 산출한다.

   ```
   dist_bg = min( d(pixel, comp) )  for comp in bg_components
   ```

   여기서 Mahalanobis 거리 제곱은 다음과 같이 정의된다.

   ```
   d(x, comp) = (x - mu)^T * Sigma^(-1) * (x - mu)
   ```

3. 동일하게 전경 컴포넌트 집합까지의 최소 Mahalanobis 거리 제곱을 산출한다.

   ```
   dist_fg = min( d(pixel, comp) )  for comp in fg_components
   ```

4. 배경(손상) 컴포넌트에 더 가까운 픽셀을 손상 부위로 분류한다.

   ```
   mask = (dist_fg > dist_bg) * 255
   ```

**후처리**

청크 처리 완료 후, 전체 마스크에 대해 다음의 후처리를 순차 적용한다.

1. **MORPH_CLOSE(3x3)**: 1-2 픽셀 수준의 경계 틈을 메운다.

   ```
   close_kernel = Ellipse(3, 3)
   mask = morphologyEx(mask, MORPH_CLOSE, close_kernel)
   ```

2. **GaussianBlur(7x7)**: 픽셀 수준의 계단 현상(jagged edge)을 완화한다.

   ```
   mask = GaussianBlur(mask, (7, 7), 0)
   ```

3. **이진화 복원**: 블러링에 의해 중간값이 된 픽셀을 127을 기준으로 이진화한다.

   ```
   mask = (mask > 127) * 255
   ```

### 4.5.6 알고리즘 특성

1. **하위 호환성**: 단일 영역 선택(배경 1개, 전경 1개)의 경우 컴포넌트가 각 1개이므로 기존의 단일 Gaussian Mahalanobis 분류와 동일한 결과를 산출한다.
2. **메모리 효율**: 청크 처리에 의해 초고해상도 이미지에서도 피크 메모리 사용량을 약 200MB로 제한한다.
3. **Canny 보정 생략**: 이미 픽셀 단위의 정밀 분류가 이루어지므로 Canny 엣지 보정은 불필요하여 생략한다.
4. **공격적 bridging 생략**: 채널별 필터 경로에서 사용하는 dilate-erode bridging을 생략하고, MORPH_OPEN만 적용한다.

---

## 4.6 Canny 엣지 보정

### 4.6.1 적용 범위

Canny 엣지 보정은 채널별 임계값 필터 경로(경로 A)에서만 적용되며, Mahalanobis 분류 경로(경로 B)에서는 생략된다.

### 4.6.2 알고리즘

임계값 기반 마스크의 경계를 실제 이미지의 엣지에 정합(snap)시켜 더 정확한 윤곽선을 얻는 것이 목적이다. 처리 절차는 다음과 같다.

**Step 1: 엣지 맵 생성**

CIE LAB 색공간의 L 채널(밝기)과 b 채널(색도)에 대해 각각 Gaussian 블러(3x3) 적용 후 Canny 엣지 검출을 수행하고, 두 결과를 OR 연산으로 결합한다.

```
L_blur = GaussianBlur(L, (3, 3), 0)
b_blur = GaussianBlur(b, (3, 3), 0)
edges_L = Canny(L_blur, 30, 90)
edges_b = Canny(b_blur, 20, 60)
edges = edges_L OR edges_b
```

**Step 2: 경계 밴드 생성**

현재 마스크의 외곽에 소정 폭의 밴드를 생성한다. 밴드 크기는 해상도에 비례하여 스케일링된다.

```
band_size = max(5, int(7 * linear_scale))
band_kernel = Ellipse(band_size, band_size)
mask_dilated = dilate(mask, band_kernel)
mask_eroded = erode(mask, band_kernel)
boundary_band = mask_dilated - mask_eroded
```

**Step 3: 밴드 내 엣지 추출 및 폐합**

밴드 영역 내에 존재하는 엣지 단편을 추출하고, MORPH_CLOSE로 폐합하여 연속적인 경계를 형성한다.

```
edge_in_band = edges AND boundary_band
close_kernel = Ellipse(close_size, close_size)
edge_closed = morphologyEx(edge_in_band, MORPH_CLOSE, close_kernel)
```

**Step 4: 마스크 정제**

침식(erode)된 마스크에 엣지 경계를 합성하고, 윤곽선 내부를 채운 후 원래 팽창 범위 내로 제한한다.

```
refined = mask_eroded OR edge_closed
contours = findContours(refined)
filled = drawContours(contours, FILLED)
result = filled AND mask_dilated
result = result OR mask_eroded
```

최종적으로, 엣지가 검출되지 않아 소실된 소규모 영역은 침식 마스크(mask_eroded)로부터 복원된다.

---

## 4.7 형태학적 처리

### 4.7.1 개요

이진 마스크에서 개별 손상 부위를 추출하기에 앞서, 끊어진 조각을 연결하고 노이즈를 제거하는 형태학적(morphological) 처리를 수행한다. 처리 방식은 검출 경로에 따라 상이하다.

### 4.7.2 채널별 필터 경로의 형태학적 처리

채널별 필터 경로(경로 A)에서는 다음의 4단계 처리를 순차 적용한다.

**1단계: Dilate (팽창) -- 끊어진 조각 연결**

Ellipse 구조 요소를 사용하여 마스크를 팽창시킨다. 팽창 커널 크기는 해상도에 따라 15px에서 50px 범위로 스케일링된다.

```
bridge_size = max(15, kernel_size * 6)
bridge_kernel = Ellipse(bridge_size, bridge_size)
mask_dilated = dilate(mask, bridge_kernel)
```

이 과정에서 인접한 손상 부위 조각이 하나의 영역으로 연결된다.

**2단계: Erode (침식) -- 원래 크기 복원**

팽창에 사용한 것과 동일한 커널로 침식을 수행하여 팽창에 의해 확대된 영역을 원래 크기에 근사하게 복원한다.

```
mask_eroded = erode(mask_dilated, bridge_kernel)
```

**3단계: OR 연산 -- 소규모 손상 부위 보존**

Dilate-Erode 과정에서 소멸된 소규모 손상 부위를 원본 마스크로부터 복원한다.

```
mask_clean = mask OR mask_eroded
```

**4단계: MORPH_OPEN -- 노이즈 제거**

Ellipse 구조 요소를 사용한 Opening 연산으로 잔여 노이즈를 제거한다. 커널 크기는 해상도에 따라 3px에서 7px 범위로 스케일링된다.

```
open_kernel = Ellipse(kernel_size, kernel_size)
mask_clean = morphologyEx(mask_clean, MORPH_OPEN, open_kernel)
```

### 4.7.3 Mahalanobis 경로의 형태학적 처리

Mahalanobis 분류 경로(경로 B)에서는 이미 픽셀 단위의 정밀 분류가 완료되어 있으므로, 공격적인 bridging(Dilate-Erode-OR)을 생략하고 MORPH_OPEN만 적용한다.

```
open_kernel = Ellipse(kernel_size, kernel_size)
mask_clean = morphologyEx(mask, MORPH_OPEN, open_kernel)
```

kernel_size는 해상도 스케일링에 의해 결정되며, 최소 3px이다.

---

## 4.8 해상도 인식 파라미터 스케일링

### 4.8.1 필요성

본 시스템은 다양한 해상도의 스캔 이미지를 처리해야 한다. 동일한 물리적 크기의 손상 부위라도 스캔 해상도에 따라 픽셀 면적이 비례적으로 변화하므로, 모든 파라미터를 해상도에 연동하여 자동 조정할 필요가 있다.

### 4.8.2 기준 해상도

본 시스템의 기준 해상도는 고해상도 TIFF 스캔의 대표적 크기인 7216 x 5412 픽셀이다.

```
REFERENCE_PIXELS = 7216 * 5412 = 39,061,392 px
```

### 4.8.3 스케일 팩터 산출

현재 처리 중인 이미지의 너비 W와 높이 H로부터 두 종류의 스케일 팩터를 산출한다.

**면적 스케일 팩터(area scale factor)**:

```
scale_factor = (W * H) / 39,061,392
```

이 값은 면적에 비례하는 파라미터(min_area, max_area 등)의 스케일링에 사용된다.

**선형 스케일 팩터(linear scale factor)**:

```
linear_scale = sqrt(scale_factor)
```

이 값은 길이에 비례하는 파라미터(커널 크기, 격자 크기 등)의 스케일링에 사용된다.

### 4.8.4 적용 대상

| 파라미터 유형 | 스케일링 방식 | 산출식 예시 |
|---------------|---------------|-------------|
| 면적 임계값 (min_area, max_area) | 면적 비례 | min_area_scaled = int(min_area * scale_factor) |
| 형태학적 커널 크기 | 선형 비례, 최소 3px | kernel_size = max(3, int(3 * linear_scale)) |
| Bridge 커널 크기 | 선형 비례, 최소 15px | bridge_size = max(15, kernel_size * 6) |
| morph_size | 선형 비례, 최소 5px | morph_size = max(5, int(9 * linear_scale)) |
| 격자 크기 (번호 부여) | 선형 비례 | grid_size_scaled = int(grid_size * linear_scale) |
| 경계 밴드 크기 (Canny) | 선형 비례, 최소 5px | band_size = max(5, int(7 * linear_scale)) |
| 가장자리 마진 | 선형 비례 | border_margin_scaled = int(margin * linear_scale) |

### 4.8.5 커널 크기 홀수 보정

OpenCV의 형태학적 연산에서 커널 크기는 홀수여야 한다. 스케일링에 의해 짝수가 산출된 경우 1을 가산하여 홀수로 보정한다.

```
if kernel_size % 2 == 0:
    kernel_size += 1
```

---

## 4.9 영역 분석 알고리즘

### 4.9.1 목적

영역 분석 알고리즘은 사용자가 선택한 배경(손상) 영역과 전경(원본 문서) 영역의 색상 분포를 비교하여 다음 두 가지를 동시에 수행한다.

1. 각 채널별 최적 임계값 자동 산출
2. GMM 기반 분류 모델 학습

### 4.9.2 채널별 통계 산출

모든 배경 영역의 픽셀을 합치고, 모든 전경 영역의 픽셀을 합친 후, 다음의 7개 채널에 대해 통계를 산출한다.

| 채널 | 색공간 | 의미 |
|------|--------|------|
| L | CIE LAB | 명도 |
| a | CIE LAB | 녹색-적색 축 |
| b | CIE LAB | 청색-황색 축 |
| S | HSV | 채도 |
| V | HSV | 명도 |
| Tex | - | 국소 분산(텍스처) |
| W | - | Whiteness Score |

### 4.9.3 분리도(Separation Score) 산출

각 채널에 대해 배경과 전경 간의 분리도를 다음과 같이 산출한다.

```
separation = |bg_mean - fg_mean| / (bg_std + fg_std + epsilon)
```

여기서 epsilon = 1e-6은 영분모 방지를 위한 정규화 상수이다.

분리도가 높을수록 해당 채널이 배경과 전경을 효과적으로 구분할 수 있음을 나타낸다.

### 4.9.4 최적 임계값 산출

각 채널에 대해 배경 쪽에 가중된 임계값을 다음과 같이 결정한다.

**배경 평균이 전경 평균보다 낮은 경우(condition = 'less')**:

```
threshold = bg_mean + (fg_mean - bg_mean) * 0.2
```

**배경 평균이 전경 평균보다 높은 경우(condition = 'greater')**:

```
threshold = fg_mean + (bg_mean - fg_mean) * 0.2
```

상기 산출식에서 0.2의 가중치는, 임계값을 배경 분포 쪽에 80%, 전경 분포 쪽에 20% 비율로 설정함을 의미한다. 이는 손상 부위의 검출 재현율(recall)을 우선시하는 설계이다.

### 4.9.5 조건(condition) 결정

```
condition = 'less'    (bg_mean < fg_mean인 경우)
condition = 'greater' (bg_mean >= fg_mean인 경우)
```

---

## 4.10 공간 번호 부여 알고리즘

### 4.10.1 목적

검출된 손상 부위에 물리적 위치에 기반한 일관된 번호를 부여하여, 커팅 레이아웃의 조각 번호와 원본 문서의 위치를 직관적으로 대응시키는 것을 목적으로 한다.

### 4.10.2 Grid 방식 (기본)

Grid 방식은 이미지를 균일한 격자로 분할하고, 격자 단위로 그룹핑한 후 정렬하여 번호를 부여하는 방식이다.

**Step 1: 격자 좌표 산출**

각 손상 부위의 중심점 (cx, cy)로부터 격자 좌표를 산출한다. 기본 격자 크기(grid_size)는 500px이다.

```
gx = cx // grid_size
gy = cy // grid_size
```

**Step 2: 격자 단위 그룹핑**

동일 격자 좌표 (gx, gy)를 가지는 손상 부위를 하나의 그룹으로 묶는다.

**Step 3: 그룹 간 정렬**

그룹을 (gy, gx) 순서, 즉 상단에서 하단으로, 좌측에서 우측으로 정렬한다.

```
sorted_keys = sorted(grid_assignments.keys(), key=lambda k: (k[1], k[0]))
```

**Step 4: 그룹 내 정렬**

각 그룹 내에서 손상 부위를 (y // 50, x) 순서로 세부 정렬한다. 여기서 y // 50은 50px 간격의 행 단위 양자화로, 유사한 높이의 손상 부위를 동일 행으로 취급한다.

```
sorted_group = sorted(group, key=lambda h: (center_y // 50, center_x))
```

**Step 5: 번호 부여**

정렬된 순서에 따라 1부터 시작하는 연속 번호를 부여한다.

### 4.10.3 기타 번호 부여 방식

| 방식 | 그룹핑 기준 | 정렬 순서 |
|------|-------------|-----------|
| row | Y 좌표 기반 행 (row_height px 간격) | 행 순서(상->하), 행 내 좌->우 |
| column | X 좌표 기반 열 (col_width px 간격) | 열 순서(좌->우), 열 내 상->하 |
| simple | 단일 그룹 (그룹핑 없음) | Y 좌표 우선, X 좌표 보조 |

---

## 4.11 문서 경계 검출

### 4.11.1 목적

스캔 이미지에서 실제 문서 영역을 자동으로 식별하여, 스캐너 배경이 손상 부위로 오검출되는 것을 방지하는 것이 목적이다. 문서 경계 외부의 영역은 마스크에서 제거된다.

### 4.11.2 방법 1: 밝기 기반 (brightness)

본 방법은 CIE LAB 색공간의 b 채널(청색-황색 축)을 이용한다. 고문서 종이는 황변에 의해 b 값이 높고, 스캐너 배경은 흰색으로 b 값이 낮으므로 이 차이를 이용한다.

**Step 1: b 채널 추출 및 Otsu 이진화**

```
lab = cvtColor(image, BGR2LAB)
L, a, b_channel = split(lab)
b_thresh, doc_mask = threshold(b_channel, 0, 255, BINARY + OTSU)
```

Otsu 알고리즘에 의해 최적 이진화 임계값이 자동 결정된다.

**Step 2: 형태학적 정리**

문서 내부의 구멍(작은 흰색 영역)을 메우기 위한 MORPH_CLOSE와, 외부 노이즈를 제거하기 위한 MORPH_OPEN을 순차 적용한다. 커널 크기는 이미지 크기에 비례한다.

```
kernel_close = max(20, int(min(W, H) * 0.005))
kernel_open  = max(5,  int(min(W, H) * 0.001))
doc_mask = morphologyEx(doc_mask, MORPH_CLOSE, Rect(kernel_close, kernel_close))
doc_mask = morphologyEx(doc_mask, MORPH_OPEN,  Rect(kernel_open,  kernel_open))
```

**Step 3: 최대 윤곽선 추출**

윤곽선을 검출하여 면적이 가장 큰 윤곽선을 문서 경계로 판정한다. 최대 윤곽선의 면적이 이미지 전체의 30% 미만인 경우 경계 검출 실패로 처리한다.

```
contours = findContours(doc_mask, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE)
largest_contour = max(contours, key=contourArea)
if contourArea(largest_contour) < W * H * 0.3:
    return None  (검출 실패)
```

**Step 4: 바운딩 사각형 산출**

최대 윤곽선으로부터 문서 영역의 바운딩 사각형 (x, y, w, h)을 산출한다.

### 4.11.3 방법 2: 엣지 기반 (edges)

본 방법은 Canny 엣지 검출과 Hough 직선 검출을 결합하여 문서의 직선적 경계를 검출한다.

**Step 1: Canny 엣지 검출**

```
gray = cvtColor(image, BGR2GRAY)
edges = Canny(gray, 50, 150)
```

**Step 2: Hough 직선 검출**

```
lines = HoughLinesP(edges, 1, pi/180,
                    threshold=100,
                    minLineLength=min(W, H) * 0.3,
                    maxLineGap=50)
```

**Step 3: 직선 분류**

검출된 직선을 각도에 따라 수평선(angle < 10 또는 angle > 170도)과 수직선(80 < angle < 100도)으로 분류한다.

**Step 4: 경계 결정**

수평선의 최소 Y와 최대 Y, 수직선의 최소 X와 최대 X로부터 문서 경계 사각형을 결정한다.

```
top    = min(horizontal_y_values)
bottom = max(horizontal_y_values)
left   = min(vertical_x_values)
right  = max(vertical_x_values)
boundary = (left, top, right - left, bottom - top)
```

수평선 또는 수직선이 2개 미만인 경우 경계 검출 실패로 처리한다.

### 4.11.4 경계 적용

검출된 경계를 마스크에 적용하면, 경계 외부의 모든 픽셀이 0(비검출)으로 설정된다.

```
bounded_mask = zeros_like(mask)
bounded_mask[y_start:y_end, x_start:x_end] = mask[y_start:y_end, x_start:x_end]
```

---

## 4.12 윤곽선-SVG 벡터 변환

### 4.12.1 목적

검출된 각 손상 부위의 윤곽선을 SVG(Scalable Vector Graphics) path 형식으로 변환하여, 레이저 커터 호환 벡터 파일을 생성하는 것이 목적이다.

### 4.12.2 Ramer-Douglas-Peucker 단순화

OpenCV의 `findContours`에 의해 추출된 윤곽선은 픽셀 단위의 다수의 꼭짓점을 포함하므로, Ramer-Douglas-Peucker 알고리즘을 적용하여 윤곽선의 형상을 보존하면서 꼭짓점 수를 감소시킨다.

```
epsilon = 0.9
approx = approxPolyDP(contour, epsilon, closed=True)
```

여기서 epsilon은 원래 윤곽선으로부터의 최대 허용 편차(픽셀 단위)이며, 0.9 픽셀로 설정되어 있다. 이 값이 클수록 단순화 정도가 높아지고, 작을수록 원래 형상에 더 충실한 결과가 산출된다.

단순화 후 꼭짓점이 3개 미만인 경우 유효한 폐합 형상을 구성할 수 없으므로 빈 문자열을 반환한다.

### 4.12.3 SVG Path 명령어

단순화된 윤곽선의 각 꼭짓점을 SVG path의 표준 명령어로 변환한다.

| 명령어 | 의미 | 용례 |
|--------|------|------|
| M x,y | MoveTo -- 시작점으로 이동 | 경로의 첫 꼭짓점 |
| L x,y | LineTo -- 직선 그리기 | 두 번째 이후의 각 꼭짓점 |
| Z | ClosePath -- 시작점으로 경로 닫기 | 경로의 마지막 |

### 4.12.4 변환 절차

꼭짓점 배열 points = [(x_0, y_0), (x_1, y_1), ..., (x_n, y_n)]에 대해 다음의 SVG path 문자열을 생성한다.

```
d = "M x_0,y_0 L x_1,y_1 L x_2,y_2 ... L x_n,y_n Z"
```

좌표값은 소수점 이하 4자리까지 기록하여 서브픽셀 정밀도를 유지한다.

```
path_data = f"M {points[0][0]:.4f},{points[0][1]:.4f}"
for point in points[1:]:
    path_data += f" L {point[0]:.4f},{point[1]:.4f}"
path_data += " Z"
```

### 4.12.5 SVG 파일 출력

각 손상 부위에 대해 개별 SVG 파일을 생성한다. 스케일 팩터(scale_factors)가 제공되는 경우, 픽셀 좌표를 실제 치수(mm)로 변환하여 SVG의 width/height 속성에 mm 단위를 적용한다. 스케일 팩터가 미제공인 경우, 픽셀 단위의 SVG를 생성한다.

```
실측 SVG의 경우:
  width  = (x_max - x_min) * scale_x  [mm]
  height = (y_max - y_min) * scale_y  [mm]
  transform = translate(-x_min * scale_x, -y_min * scale_y)
              scale(scale_x, scale_y)
```

---

## 4.13 필터 채널 구성

### 4.13.1 지원 채널 목록

본 시스템은 다음의 5개 필터 채널을 지원하며, 각 채널은 독립적으로 활성/비활성 설정 및 임계값 조정이 가능하다.

| 채널 | 명칭 | 색공간 | 범위 | 기본값 | 기본 조건 | 기본 활성 여부 |
|------|------|--------|------|--------|-----------|---------------|
| S | Saturation | HSV | 0-255 | 30 | less | 활성 |
| L | Lightness | CIE LAB | 0-255 | 200 | greater | 활성 |
| b | b channel | CIE LAB | 0-255 | 138 | less | 활성 |
| Tex | Texture | 국소 분산 | 0-1000 | 500 | less | 비활성 |
| W | Whiteness | 복합 지표 | 0-255 | 180 | greater | 비활성 |

### 4.13.2 필터 결합 모드

복수의 필터 채널이 활성화된 경우, 다음의 결합 모드 중 하나를 선택하여 최종 마스크를 생성한다.

- **AND 모드**: 모든 활성 채널의 조건을 동시에 만족하는 픽셀만 검출한다. 높은 정밀도(precision)를 우선시하는 설정이다.
- **OR 모드**: 하나 이상의 활성 채널 조건을 만족하는 픽셀을 검출한다. 높은 재현율(recall)을 우선시하는 설정이다.

---

## 4.14 가장자리 연결 영역 제거

### 4.14.1 적용 조건

문서 경계 검출(boundary detection) 기능이 비활성화(OFF)된 경우에 적용된다.

### 4.14.2 알고리즘

이미지의 4변(상, 하, 좌, 우) 가장자리에 위치한 흰색 픽셀(값 255)로부터 Flood Fill을 실행하여, 가장자리에서 연결된 모든 흰색 영역을 제거한다.

```
for 상단 가장자리의 각 x:
    if mask[0, x] == 255:
        floodFill(mask, (x, 0), 0)

for 하단 가장자리의 각 x:
    if mask[H-1, x] == 255:
        floodFill(mask, (x, H-1), 0)

for 좌측 가장자리의 각 y:
    if mask[y, 0] == 255:
        floodFill(mask, (0, y), 0)

for 우측 가장자리의 각 y:
    if mask[y, W-1] == 255:
        floodFill(mask, (W-1, y), 0)
```

이를 통해 문서 경계 검출 없이도 스캐너 배경이 손상 부위로 오검출되는 현상을 억제한다.

---

## 4.15 텍스처(국소 분산) 맵 산출

### 4.15.1 목적

텍스처 필터 채널(Tex)에 사용되는 국소 분산 맵을 산출한다. 텍스처 값이 낮은 영역은 평탄한 표면(구멍, 배경)을 나타내고, 높은 영역은 인쇄/필사 텍스트 또는 그림이 있는 영역을 나타낸다.

### 4.15.2 산출 공식

입력 이미지를 그레이스케일로 변환한 후, 15x15 커널의 국소 분산을 산출한다.

```
img_float = gray.astype(float32)
kernel = ones(15, 15) / 225

local_mean    = filter2D(img_float, kernel)
local_mean_sq = filter2D(img_float^2, kernel)
variance      = max(local_mean_sq - local_mean^2, 0)
texture       = sqrt(variance)
```

산출된 텍스처 맵은 최댓값으로 정규화한 후 0-255 범위의 uint8로 변환하여 필터 채널로 사용된다.
